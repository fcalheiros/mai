#!/bin/bash

# ====================================================================
# mai.sh - MyAI - Command-line script to interact with the Gemini API
# Version 0.3
# ====================================================================

VERSION="0.3"
API_KEY=""
URL=""
OUTPUT_DIR="$HOME/maiout"
CONTENT_TYPE="application/json"

CONFIG_DIR="$HOME/.local/.mai"
CONFIG_FILE="$CONFIG_DIR/mai.conf"
HISTORY_FILE="$CONFIG_DIR/history.json"
LOG_FILE="$OUTPUT_DIR/mai.log"

# ---------------------------------------------------------
# Dependency check
# ---------------------------------------------------------
check_dependencies() {
    if ! command -v jq &> /dev/null || ! command -v curl &> /dev/null; then
        echo "Critical Error: This script requires 'jq' and 'curl' to be installed."
        exit 1
    fi
}
check_dependencies

# ---------------------------------------------------------
# Create configuration
# ---------------------------------------------------------
create_config() {
    mkdir -p "$CONFIG_DIR"

    echo "Enter your Gemini/Gemma API key:"
    read API_KEY

    echo "Enter the model you want to use (e.g., gemini-2.5-flash-lite, gemma-3-27b-it):"
    read MODEL

    URL="https://generativelanguage.googleapis.com/v1beta/models/$MODEL:generateContent"

    echo "API_KEY=$API_KEY" > "$CONFIG_FILE"
    echo "URL=$URL" >> "$CONFIG_FILE"
    echo "OUTPUT_DIR=$HOME/maiout" >> "$CONFIG_FILE"

    echo "Configuration file created at $CONFIG_FILE"
}

# ---------------------------------------------------------
# Read configuration
# ---------------------------------------------------------
read_config() {
    while IFS='=' read -r key value; do
        case "$key" in
            API_KEY) API_KEY="$value" ;;
            URL) URL="$value" ;;
            OUTPUT_DIR) OUTPUT_DIR="$value" ;;
        esac
    done < "$CONFIG_FILE"
}

if [ ! -f "$CONFIG_FILE" ]; then
    create_config
fi

read_config

if [ -z "$API_KEY" ]; then
    echo "Error: API_KEY not configured in $CONFIG_FILE"
    exit 1
fi

# ---------------------------------------------------------
# Help
# ---------------------------------------------------------
show_help() {
    echo "Usage: $0 \"your text here\" [file] [options]"
    echo ""
    echo "Options:"
    echo "  --debug         Save debug info to $OUTPUT_DIR/debug.log"
    echo "  --new, -n       Start a new conversation"
    echo "  --help, -h      Show help"
    echo "  --version       Show version"
    echo "  --config        Edit configuration"
    echo "  --list-models   List available Gemini/Gemma models"
    echo "  --logs          Show the mai.log file"
    exit 0
}

edit_config() {
    ${EDITOR:-nano} "$CONFIG_FILE"
}

# ---------------------------------------------------------
# Argument parsing
# ---------------------------------------------------------
DEBUG_MODE=false
NEW_CONVERSATION=false
SHOW_LOGS=false
LIST_MODELS=false
ARGS=()

for arg in "$@"; do
    case "$arg" in
        --debug) DEBUG_MODE=true ;;
        --new|-n) NEW_CONVERSATION=true ;;
        --help|-h) show_help ;;
        --version) echo "mai version: $VERSION"; exit 0 ;;
        --config) edit_config; exit 0 ;;
        --list-models) LIST_MODELS=true ;;
        --logs) SHOW_LOGS=true ;;
        *) ARGS+=("$arg") ;;
    esac
done

# ---------------------------------------------------------
# List models
# ---------------------------------------------------------
list_models() {
    echo "Fetching available Gemini/Gemma models..."
    curl -s "https://generativelanguage.googleapis.com/v1beta/models?key=${API_KEY}" \
        | jq -r '.models[].name | sub("^models/"; "")'
    exit 0
}

if $LIST_MODELS; then
    list_models
fi

# ---------------------------------------------------------
# Show logs
# ---------------------------------------------------------
show_logs() {
    if [ ! -f "$LOG_FILE" ]; then
        echo "No logs found at $LOG_FILE"
        exit 0
    fi

    echo "=== MAI LOGS ==="
    cat "$LOG_FILE"
    exit 0
}

if $SHOW_LOGS; then
    show_logs
fi

# ---------------------------------------------------------
# New conversation
# ---------------------------------------------------------
if $NEW_CONVERSATION; then
    echo "[]" > "$HISTORY_FILE"
    echo "New conversation started."
fi

if [ -z "${ARGS[0]}" ]; then
    show_help
fi

TEXT="${ARGS[0]}"
FILE="${ARGS[1]}"

mkdir -p "$OUTPUT_DIR"

# ---------------------------------------------------------
# Read history
# ---------------------------------------------------------
read_history() {
    if [ -f "$HISTORY_FILE" ] && ! $NEW_CONVERSATION; then
        cat "$HISTORY_FILE"
    else
        echo "[]"
    fi
}

HISTORY=$(read_history)

# ---------------------------------------------------------
# Build JSON (safe for large data)
# ---------------------------------------------------------
if [ -n "$FILE" ]; then
    MIME_TYPE=$(file -b --mime-type "$FILE")
    BASE64_DATA=$(base64 -w 0 "$FILE")

    CONTENTS=$(echo "$HISTORY" | jq \
        --arg text "$TEXT" \
        --arg mime "$MIME_TYPE" \
        --arg data "$BASE64_DATA" \
        '. + [{"role":"user","parts":[{"text":$text},{"inlineData":{"mimeType":$mime,"data":$data}}]}]')
else
    CONTENTS=$(echo "$HISTORY" | jq \
        --arg text "$TEXT" \
        '. + [{"role":"user","parts":[{"text":$text}]}]')
fi

DATA=$(jq -n --argjson c "$CONTENTS" '{contents: $c}')

# ---------------------------------------------------------
# API Request
# ---------------------------------------------------------
RESPONSE=$(echo "$DATA" | curl -s -X POST \
  -H "Content-Type: ${CONTENT_TYPE}" \
  -d @- \
  "${URL}?key=${API_KEY}")

if $DEBUG_MODE; then
    echo "--- Request ---" > "$OUTPUT_DIR/debug.log"
    echo "$DATA" >> "$OUTPUT_DIR/debug.log"
    echo "--- Response ---" >> "$OUTPUT_DIR/debug.log"
    echo "$RESPONSE" >> "$OUTPUT_DIR/debug.log"
fi

# ---------------------------------------------------------
# Parse response
# ---------------------------------------------------------
if ! echo "$RESPONSE" | jq -e '.candidates' >/dev/null; then
    echo "Error: Response does not contain candidates."
    exit 1
fi

TEXT_RESPONSE=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[] | select(.text) | .text')
FILES=$(echo "$RESPONSE" | jq -c '.candidates[0].content.parts[] | select(.inlineData)')

if [ -n "$TEXT_RESPONSE" ]; then
    echo "$TEXT_RESPONSE"
fi

if [ -n "$FILES" ]; then
    while IFS= read -r FILE_DATA; do
        MIME_TYPE=$(echo "$FILE_DATA" | jq -r '.inlineData.mimeType')
        BASE64_DATA=$(echo "$FILE_DATA" | jq -r '.inlineData.data')
        EXT="${MIME_TYPE#*/}"
        OUTFILE="$OUTPUT_DIR/output_$(date +%s).$EXT"
        echo "$BASE64_DATA" | base64 -d > "$OUTFILE"
        echo "File saved: $OUTFILE"
    done <<< "$FILES"
fi

# ---------------------------------------------------------
# Save history
# ---------------------------------------------------------
if ! $NEW_CONVERSATION; then
    CLEAN_TEXT_RESPONSE=$(echo "$TEXT_RESPONSE" | jq -Rs .)
    NEW_HISTORY=$(echo "$HISTORY" | jq \
        --arg text "$TEXT" \
        --argjson resp "$CLEAN_TEXT_RESPONSE" \
        '. + [{"role":"user","parts":[{"text":$text}]},{"role":"model","parts":[{"text":$resp}]}]')
    echo "$NEW_HISTORY" > "$HISTORY_FILE"
fi

# ---------------------------------------------------------
# Automatic logging
# ---------------------------------------------------------
mkdir -p "$OUTPUT_DIR"

LOG_ENTRY_TIME=$(date +"%Y-%m-%d %H:%M:%S")
CLEAN_LOG_RESPONSE=$(echo "$TEXT_RESPONSE" | tr -d '\n\r')

echo "$LOG_ENTRY_TIME | prompt: \"$TEXT\" | response: \"$CLEAN_LOG_RESPONSE\"" >> "$LOG_FILE"

if [ -n "$FILES" ]; then
    echo "$LOG_ENTRY_TIME | files returned: yes" >> "$LOG_FILE"
else
    echo "$LOG_ENTRY_TIME | files returned: no" >> "$LOG_FILE"
fi
